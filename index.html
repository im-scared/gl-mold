<!DOCTYPE html>
<html>
  <head>
    <title>WebGL Game of Life</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="gol.css"/>
    <script src="lib/igloo-0.1.0.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="js/p.js"></script>
  </head>
  <body onload="main()">
    <h1>WebGL Game of Life</h1>
    <!-- Canvas dimensions must be powers of two. -->
    <canvas id="life" width="1024" height="512"></canvas>
    <div class="description">
      <p>
        This Game of Life simulation is running entirely on your
        graphics card. The simulation state swaps back and forth
        between two texture buffers in the GPU's memory.
      </p>
      <h2>Controls</h2>
      <ul>
        <li>
          <span class="input">Left-click</span>
          <span class="result">draw live cells</span>
        </li>
        <li>
          <span class="input">Middle/right-click</span>
          <span class="result">draw dead cells</span>
        </li>
        <li>
          <span class="input">[SPACE]</span>
          <span class="result">toggle pause/play</span>
        </li>
        <li>
          <span class="input">[r]</span>
          <span class="result">reset to random state</span>
        </li>
        <li>
          <span class="input">[DEL]</span>
          <span class="result">clear the simulation state</span>
        </li>
        <li>
          <span class="input">s</span>
          <span class="result">snapshot the simulation state</span>
        </li>
        <li>
          <span class="input">shift+s</span>
          <span class="result">restore from snapshot</span>
        </li>
      </ul>
    </div>
    <div class="fps">
    </div>
    <div class="ver">
      v0.4.5
    </div>


    <script type="text/x-fragment-shader" id="particle-step-vert">
      #version 300 es
      precision mediump float;

      /* Number of seconds since the animation started */
      uniform float u_Time;

      /* Number of seconds (possibly fractional) that has passed since the last
         update step. */
      uniform float u_TimeDelta;

      uniform float u_RandSeed;

      /* This is the gravity vector. It's a force that affects all particles all the
         time.*/
      uniform vec2 u_Gravity;

      /* This is the point from which all newborn particles start their movement. */
      uniform vec2 u_Origin;

      uniform float u_MinAge;
      uniform float u_MaxAge;

      /* The min and max values of the (scalar!) speed assigned to a newborn
         particle.*/
      uniform float u_MinSpeed;
      uniform float u_MaxSpeed;

      /* Inputs. These reflect the state of a single particle before the update. */

      /* Where the particle is. */
      in vec2 i_Position;

      /* Age of the particle in seconds. */
      in float i_Age;

      /* How long this particle is supposed to live. */
      in float i_Life;

      /* Which direction it is moving, and how fast. */
      in vec2 i_Velocity;

      /* Outputs. These mirror the inputs. These values will be captured
         into our transform feedback buffer! */
      out vec2 v_Position;
      out float v_Age;
      out float v_Life;
      out float v_Theta;
      out vec2 v_Velocity;

      const float TAU = 6.2831853071;

      float rand(in float n) {
        return fract(sin(n + u_RandSeed) * 43758.5453123);
      }

      // 2D Random
      float rand(in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233)) + u_RandSeed) * 43758.5453123);
      }

      // 2D Noise based on Morgan McGuire @morgan3d
      // https://www.shadertoy.com/view/4dS3Wd
      float noise (in vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);

          // Four corners in 2D of a tile
          float a = rand(i);
          float b = rand(i + vec2(1.0, 0.0));
          float c = rand(i + vec2(0.0, 1.0));
          float d = rand(i + vec2(1.0, 1.0));

          // Smooth Interpolation

          // Cubic Hermine Curve.  Same as SmoothStep()
          vec2 u = f*f*(3.0-2.0*f);
          // u = smoothstep(0.,1.,f);

          // Mix 4 coorners percentages
          return mix(a, b, u.x) +
                  (c - a)* u.y * (1.0 - u.x) +
                  (d - b) * u.x * u.y;
      }

      vec2 noise2(in vec2 st, in float offset, in float scale) {
        return vec2(
          noise((st + vec2(offset))/scale),
          noise((st + vec2(offset * 1.4137))/scale)
        );
      }

      void main() {
        if (i_Age >= i_Life) {
          /* Particle has exceeded its lifetime! Time to spawn a new one
             in place of the old one, in accordance with our rules.*/

          /* First, choose where to sample the random texture. I do it here
             based on particle ID. It means that basically, you're going to
             get the same initial random values for a given particle. The result
             still looks good. I suppose you could get fancier, and sample
             based on particle ID *and* time, or even have a texture where values
             are not-so-random, to control the pattern of generation. */
          // float r_1 = rand(rand(float(gl_VertexID)) + 0.0036715 * u_Time);
          float r_1 = rand(float(gl_VertexID) + 0.0036715 * u_Time);

          /* Decide the direction of the particle based on the first random value.
             The direction is determined by the angle theta that its vector makes
             with the vector (1, 0).*/
          float theta = r_1*TAU;
          v_Theta = theta;

          /* Derive the x and y components of the direction unit vector.
             This is just basic trig. */
          float x = cos(theta);
          float y = sin(theta);

          /* Return the particle to origin. */
          v_Position = u_Origin;

          /* It's new, so age must be set accordingly.*/
          v_Age = 0.0;
          float r_3 = rand(float(gl_VertexID) + 0.1543165*u_Time);
          v_Life = u_MinAge + r_3*(u_MaxAge - u_MinAge);

          /* Generate final velocity vector. We use the second random value here
             to randomize speed. */
          float r_2 = rand(float(gl_VertexID) + 0.056934 * u_Time);
          float speed = u_MinSpeed + r_2*(u_MaxSpeed - u_MinSpeed);
          v_Velocity = vec2(x, y)*speed;

        } else {
          /* Update parameters according to our simple rules.*/
          v_Position = i_Position + i_Velocity * u_TimeDelta;
          v_Age = i_Age + u_TimeDelta;
          v_Life = i_Life;
          vec2 force = 0.7 * (2.0 * noise2(i_Position, 4.365, 0.1) - vec2(1.0));
          v_Velocity = i_Velocity + u_Gravity * u_TimeDelta + force * u_TimeDelta;
        }
      }
    </script>
    <script type="text/x-fragment-shader" id="particle-noop-frag">
      #version 300 es
      precision mediump float;

      out vec4 o_FragColor;

      void main() {
        o_FragColor = vec4(1.0);
      }
    </script>
    <script type="text/x-fragment-shader" id="particle-render-vert">
      #version 300 es
      precision mediump float;

      in vec2 i_Position;
      in float i_Age;
      in float i_Life;
      in float i_Theta;
      in vec2 i_Velocity;

      out float v_Age;
      out float v_Life;
      out float v_Theta;

      void main() {
        /* Set varyings so that frag shader can use these values too.*/
        v_Age = i_Age;
        v_Life = i_Life;
        v_Theta = i_Theta;

        /* Vary point size based on age. Make old particles shrink. */
        float t = i_Age/i_Life;
        gl_PointSize = 3.0;

        gl_Position = vec4(i_Position, 0.0, 1.0);
      }
    </script>
    <script type="text/x-fragment-shader" id="particle-render-frag">
      #version 300 es
      precision mediump float;
      uniform float u_Time;
      in float v_Age;
      in float v_Life;
      in float v_Theta;

      out vec4 o_FragColor;

      const float TAU = 6.2831853071;

      /* From http://iquilezles.org/www/articles/palettes/palettes.htm */
      vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )
      {  return a + b*cos( 6.28318*(c*t+d) ); }

      void main() {
        // float t = v_Age/v_Life;
        float t = fract(v_Theta / TAU);
        vec3 a, b, c, d;
        a = vec3(0.5, 0.5, 0.5);
        b = vec3(0.5, 0.5, 0.5);
        c = vec3(2.0, 1.0, 0.0);
        d = vec3(0.50, 0.20, 0.25);
        vec3 col = palette(1.0 - t, a, b, c, d);
        o_FragColor = vec4(col, 0.6*sqrt(1.0 - t*t));
      }
    </script>
  </body>
</html>
